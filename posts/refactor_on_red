In a recent spec I was writing, one of the tests was about sanity-checking the content of several files I am using in production. The test loads the files via a series of async [fs.readFile](http://nodejs.org/api/fs.html#fs_fs_readfile_filename_options_callback) calls. It then inspects the content of each file by iterating over the `bodyById` object, making sure a minimal-length criterion is met. My first implementation for the last part looked as follows (see [model.spec.js](https://github.com/imaman/green-site/blob/b99b9745181ec0479d55d92d56ac43204bd25acb/spec/model.spec.js#L20)):

    Object.keys(bodyById).forEach(function(k) {
      var body = bodyById[k];
      expect(body).toBeTruthy();
      expect(body.length).toBeGreaterThan(minLength);
    });
    done();


Unfortunately, this test did not perform as expected. Specifically, in situations where `body` was falsey jasmine-node did not print the proverbial `T tests, A assertions, F failure, S skipped` line and its exit code was 0 which indicates that from jasmine-node's standpoint all tests have passed. 

After several iterations of trial-and-error I arrived at [this](https://github.com/imaman/green-site/blob/b99b9745181ec0479d55d92d56ac43204bd25acb/spec/model.spec.js#L20):

    try {
      Object.keys(bodyById).forEach(function(k) {
        var body = bodyById[k];
        expect(body).toBeTruthy();
        expect(body.length).toBeGreaterThan(minLength);
      });
    } catch(e) {}
    done();


To my surprise this version worked! this is counter-intuitive as this version catches thrown exceptions and silently ignored them. I would expect such a change to make the tests even less sensitive, but I could argue with the facts: with this version, min-length violations were caught are properly reported. I committed the code.

A few days later I got back to it. I wasn't satisfied with this "solution". Sure, it worked, but (a) I didn't understand why, and (b) I was sure there is a better solution.

When we are not satisfied with production code we refactor it: first, we verify the all tests are Green, we then apply a transformation, run the tests again (to verify overall behavior was preserved) and repeat until the code reaches a desired state.

This procedure is not safe for refactoring tests: when transforming tests one may unintentionally mute the assertions there. Running the tests again will be pointless. Even if you get a Green you cannot trust it.  Here is one quick example for such these deadly transformations. Imagine we have test that verifies that a certain div is present and has a non-empty content:

    expect(browser.text('.some-class')).toBeTruthy();

If our refactoring haphazardly drops the class selector:

    expect(browser.text('')).toBeTruthy();

We end up with an assertion that always succeeds and thus, tests nothing.

The solution to this predicament is simple:

>###Refactor Tests Only On Red

Coming to think about, it makes perfect sense: tests work correctly when they can produce Red. Thus, if we want to refactor tests we first need to make the tests *Red*. If the test continue to be Red after the refactoring then we can be quite sure that the refactoring is safe.

To make things more concrete here is the series of steps that I used when I refactored my jasmine-node spec, getting rid of that irritating `catch(e) {}` block.
 
#### Introduce an intentional break

I stated by inducing the failure. In this case, this was achieved by changing [model.js](https://github.com/imaman/green-site/commit/b99b9745181ec0479d55d92d56ac43204bd25acb). I added the following entry to the `posts` list:

      {
        id: "1",
        title: 'some title',
        body: '',
        publishedAt: '2014-01-29T11:41:00+02:00',
      }

As this entry has an empty body field, it will break the `expect(body.length).toBeGreaterThan(minLength);` assertion in the [defines a body for every post](https://github.com/imaman/green-site/blob/b99b9745181ec0479d55d92d56ac43204bd25acb/spec/model.spec.js#L20) spec. Indeed, when we run the specs we get a failure, and the return value (`$?`) is non-zero:

    $ npm test

    > application-name@0.0.1 test ....
    ....

    .Express server started at http://localhost:3001
    127.0.0.1 - - [Wed, 29 Jan 2014 18:30:51 GMT] "GET /posts/4 HTTP/1.1" 200 1256 "-" "Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/2.0.0-alpha24"

    Finished in 2.384 seconds
    13 tests, 24 assertions, 1 failure, 0 skipped


    npm ERR! weird error 1
    npm ERR! not ok code 0
    $ echo $?
    1

This is exactly how we expect the test to behave. 

#### First refactoring step

I [change the block](https://github.com/imaman/green-site/commit/4f0cb55e870d55d7018dee4401a629a7073d1103) to what I initially expected to work: 

    Object.keys(bodyById).forEach(function(k) {
      var body = bodyById[k];
      expect(body).toBeTruthy();
      expect(body.length).toBeGreaterThan(minLength);
    });
    done();

As suspected, going back to this code brought back the original problem: the tests are *not* failing:

    $ npm test

    > application-name@0.0.1 test ....
    ....

    .Express server started at http://localhost:3001
    127.0.0.1 - - [Wed, 29 Jan 2014 18:48:43 GMT] "GET /posts/4 HTTP/1.1" 200 1256 "-" "Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/2.0.0-alpha24"
    $ echo $?
    0

So, jasmine-node think is saying "Green". but as we're refactoring tests and we're under an intentionally induced breakage, the Red/Green semantics is reversed: Red means 'Good'. Green means 'something is not working properly'.


#### Second refactoring step

So, my first naive refactoring step was not successful (as it led me to Green). At this point I consulted the manual and found the 
`--captureExceptions` flag:

    --captureExceptions: listen to global exceptions, report them and exit (interferes with Domains in NodeJs, so do not use if using Domains as well.

I therefore added this flag to my jasmine-node configuration by editing the `scripts.test` value in [package.json](https://github.com/imaman/green-site/commit/5285e4841a6710f01577eb165574e8b3928a1dca):

    {
      "name": "application-name",
      "version": "0.0.1",
      "private": true,
      "scripts": {
        "start": "node site.js",
        "test": "jasmine-node --captureExceptions spec"
      },
      "dependencies": {
        "escape-html": "1.0.1",
        ....
      }
    }

and I ran the tests again:

    $ npm test

    > application-name@0.0.1 test ....
    ....
    .Express server started at http://localhost:3001
    127.0.0.1 - - [Wed, 29 Jan 2014 12:24:03 GMT] "GET /posts/4 HTTP/1.1" 200 1256 "-" "Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/2.0.0-alpha24"
    ...TypeError: Cannot read property 'length' of undefined
        at /home/imaman/workspace/green-site/spec/model.spec.js:34:20
        at Array.forEach (native)
        at oneDown (/home/imaman/workspace/green-site/spec/model.spec.js:31:29)
        at /home/imaman/workspace/green-site/spec/model.spec.js:47:9
        at /home/imaman/workspace/green-site/model.js:22:9
        at fs.js:266:14
        at Object.oncomplete (fs.js:107:15)
    npm ERR! weird error 1
    npm ERR! not ok code 0
    $ echo $?
    1

Woohoo! This step got us back on *Red*. We preserved the original behavior

#### Revert intentional breakage 

This stage is trivial but nonetheless important. As we just finished refactoring the tests, we need to get out of the Red zone by [reverting the breakage](https://github.com/imaman/green-site/commit/d7fec60adb525d3ad3d967d8dfff3c49b482b0a5
).

#### Verify Greenness.

One last time:

    $ npm test
    > application-name@0.0.1 test ....
    ....
    127.0.0.1 - - [Fri, 31 Jan 2014 22:44:29 GMT] "GET /posts/4 HTTP/1.1" 200 1256 "-" "Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/2.0.0-alpha24"

    Finished in 2.475 seconds
    13 tests, 27 assertions, 0 failures, 0 skipped

    $ echo $?
    0
  

Side note: In node.js almost everything is async. Thus, a test needs a way to indicate that "all checks are over". This is achieved by the `done()` call which invokes a callback that is passed-in to each test by the testing framework.

